<html><head><title>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece.</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>REGE(blockmodeling)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   REGE">
<param name="keyword" value="R:   REGE.for">
<param name="keyword" value="R:   REGE.nm.for">
<param name="keyword" value="R:   REGE.ow">
<param name="keyword" value="R:   REGE.ow.for">
<param name="keyword" value="R:   REGE.ownm.for">
<param name="keyword" value="R:   REGD.for">
<param name="keyword" value="R:   REGD.ow.for">
<param name="keyword" value="R:   REGE.FC">
<param name="keyword" value="R:   REGE.FC.ow">
<param name="keyword" value=" REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece.">
</object>


<h2>REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece.</h2>


<h3>Description</h3>

<p>
REGE - Algorithms for compiting (dis)similarities in terms of regular equivalnece (White and Reitz, 1983):
</p>
<p>
<code>REGE, REGE.for</code> - Classical REGE or REGGE, as also implemented in Ucinet. Similarities in terms of regular equivalnece are computed.  The <code>REGE.for</code> is a wraper for calling the FORTRAN subrutine writen by White (1985a), modified to be called by R. The <code>REGE</code> does the same, however it is written in R. The functions with and without ".for" differ only in wheater they are implemeted in R of FORTRAN. Needless to say, the funcitons implemeted in FORTRAN are much faster.
</p>
<p>
<code>REGE.ow, REGE.ow.for</code> - The above function, modified so that a best match is searhed for for each arc speleratly (and not for both arcs, if they exist, together)
</p>
<p>
<code>REGE.nm.for</code> - REGE or REGGE, modified to to use row and column normalited matrices instead of the original matrix.
</p>
<p>
<code>REGE.ownm.for</code> - The above function, modified so that a best match is searhed for for each arc speleratly (and not for both arcs, if they exist, together)
</p>
<p>
<code>REGD.for</code> - REGD or REGDI, a dissimilarity version of the classical REGE or REGGE. Dissimilarities in terms of regular equivalnece are computed.  The <code>REGD.for</code> is a wraper for calling the FORTRAN subrutine writen by White (1985b), modified to be called by R.
</p>
<p>
<code>REGE.FC</code>  - Acctually an erlier version of REGE. The diference is in the denominator. See Žiberna (2006) for details.
</p>
<p>
<code>REGE.FC.ow</code> - The above function, modified so that a best match is searhed for for each arc speleratly (and not for both arcs, if they exist, together)
</p>


<h3>Usage</h3>

<pre>
REGE(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)
REGE.for(M, iter = 3, E = 1)
REGE.nm.for(M, iter = 3, E = 1)
REGE.ow(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)
REGE.ow.for(M, iter = 3, E = 1)
REGE.ownm.for(M, iter = 3, E = 1)
REGD.for(M, iter = 3, E = 0)
REGD.ow.for(M, iter = 3, E = 0)
REGE.FC(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)
REGE.FC.ow(M, E = 1, iter = 3, until.change = TRUE, use.diag = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>M</code></td>
<td>
Matrix or a 3 dimensional array representing the network. The third dimension allows for several relations to be analyzed.</td></tr>
<tr valign="top"><td><code>E</code></td>
<td>
Initial (dis)similarity in terms of regular equivalnece.</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
The desired number of itetations</td></tr>
<tr valign="top"><td><code>until.change</code></td>
<td>
Should the iterations be stop when no change occours</td></tr>
<tr valign="top"><td><code>use.diag</code></td>
<td>
Should the diagonal be used. If <code>FALSE</code>, all diagonal elements are set to 0.</td></tr>
</table>

<h3>Value</h3>

<table summary="R argblock">
<tr valign="top"><td><code>E </code></td>
<td>
A matrix of (dis)similarities in terms of regular equivalnece</td></tr>
<tr valign="top"><td><code>Eall </code></td>
<td>
An array of (dis)similarity matrices in terms of regular equivalnece, each third dimmension represets one iteration. For ".for" functions, only the initial and the final (dis)similarities are returned.</td></tr>
<tr valign="top"><td><code>M</code></td>
<td>
Matrix or a 3 dimensional array representing the network used in the call.</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
The desired number of itetations</td></tr>
<tr valign="top"><td><code>use.diag</code></td>
<td>
Should the diagonal be used - for functions implemeted in R only.</td></tr>
</table>
<p>

...</p>

<h3>Author(s)</h3>

<p>
Aleš Žiberna based on Douglas R. White's original REGE and REGD
</p>


<h3>References</h3>

<p>
ŽIBERNA, Aleš. Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. J. math. sociol., 2008, vol. 32, no. 1,  57-84. <a href="http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207">http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207</a>.
</p>
<p>
White, D. R., K. P. Reitz (1983): "Graph and semigroup homomorphisms on networks of relations". Social Networks, 5, p. 193-234.
</p>
<p>
White, Douglas R.(1985a): DOUG WHITE'S REGULAR EQUIVALENCE PROGRAM. http://eclectic.ss.uci.edu/~drwhite/REGGE/REGGE.FOR (12.5.2005).
</p>
<p>
White, Douglas R.(1985b): DOUG WHITE'S REGULAR DISTANCES PROGRAM. http://eclectic.ss.uci.edu/~drwhite/REGGE/REGDI.FOR (12.5.2005).
</p>
<p>
White, Douglas R.(2005): REGGE (web page). http://eclectic.ss.uci.edu/~drwhite/REGGE/ (12.5.2005).
</p>


<h3>See Also</h3>

<p>
<code><a onclick="findlink('graphics', 'hist.html')" style="text-decoration: underline; color: blue; cursor: hand">hist</a></code>, <code><a href="sedist.html">sedist</a></code>, <code><a href="crit.fun.html">crit.fun</a></code>, <code><a href="opt.par.html">opt.par</a></code>,<code><a href="opt.random.par.html">opt.random.par</a></code>,<code><a href="opt.random.par.html">opt.these.par</a></code>,<code><a href="check.these.par.html">check.these.par</a></code>,<code><a href="plot.mat.html">plot.mat</a></code>
</p>


<h3>Examples</h3>

<pre>
n&lt;-20
net&lt;-matrix(NA,ncol=n,nrow=n)
clu&lt;-rep(1:2,times=c(5,15))
tclu&lt;-table(clu)
net[clu==1,clu==1]&lt;-0
net[clu==1,clu==2]&lt;-rnorm(n=tclu[1]*tclu[2],mean=4,sd=1)*sample(c(0,1),size= tclu[1]*tclu[2],replace=TRUE,prob=c(3/5,2/5))
net[clu==2,clu==1]&lt;-0
net[clu==2,clu==2]&lt;-0

D&lt;-REGE.for(M=net)$E #any other REGE function can be used
plot.mat(net, clu=cutree(hclust(d=as.dist(1-D),method="ward"),k=2)) #REGE returns similarities, which have to be converted to disimilarities

res&lt;-opt.random.par(M=net,k=2,npar=10,approach="ss",blocks="reg", FUN="max")
plot(res) #Hopefully we get the original partition
</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>blockmodeling</em> version 0.1.5 <a href="00Index.html">Index]</a></div>

</body></html>
