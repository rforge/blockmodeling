<html><head><title>Functions for plotting a partitioned matrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>plot.mat(blockmodeling)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   plot.mat">
<param name="keyword" value="R:   plot.mat.nm">
<param name="keyword" value="R:   plot.crit.fun">
<param name="keyword" value="R:   plot.opt.par">
<param name="keyword" value="R:   plot.opt.par.mode">
<param name="keyword" value="R:   plot.opt.more.par">
<param name="keyword" value="R:   plot.opt.more.par.mode">
<param name="keyword" value="R:   plot.check.these.par">
<param name="keyword" value=" Functions for plotting a partitioned matrix">
</object>


<h2>Functions for plotting a partitioned matrix</h2>


<h3>Description</h3>

<p>
The main function <code>plot.mat</code> plots a (optionally partitioned) matrix. If the matrix is partitioned, the rows and columns of the matrix are rearranged according to the partitions. Other functions are only wrappers for <code>plot.mat</code> for convenience when plotting the results of the corresponding functions. The <code>plot.mat.nm</code> plots two matrices based on M, normalized by rows and columns, next to each other.
</p>


<h3>Usage</h3>

<pre>
plot.mat(M, clu = NULL, ylab = "", xlab = "", main = NULL, print.val = !length(table(M)) &lt;= 2, print.0 = FALSE, plot.legend = !print.val &amp;&amp; !length(table(M)) &lt;= 2, print.legend.val = "out", print.digits.legend = 2, print.digits.cells = 2, print.cells.mf = NULL , outer.title = !plot.legend, title.line = ifelse(outer.title, -1.5, 7), mar = c(0.5, 7, 8.5, 0) + 0.1, cex.val = "default", val.x.coor.cor = 0, val.y.coor.cor = 0, cex.legend = 1, legend.title = "Legend", cex.axes = "default", print.axes.val = NULL, print.x.axis.val = !is.null(colnames(M)), print.y.axis.val = !is.null(rownames(M)), x.axis.val.pos = 1.1, y.axis.val.pos = -0.1, cex.main = par()$cex.main, cex.lab = par()$cex.lab, yaxis.line = -1.5, xaxis.line = -1, legend.left = 0.4, legend.up = 0.03, legend.size = 1/10, legend.text.hor.pos = 0.5, par.line.width = 3, par.line.col = "blue", IM.dens = NULL,IM = NULL,       dens.leg = c(null=20), blackdens = 70, plotLines =TRUE,...)

plot.mat.nm(M,...)

S3 method for class 'crit.fun':
plot(x, main = NULL, ...)

S3 method for class 'opt.par':
plot(x, main = NULL, which = 1, ...)

S3 method for class 'opt.par.mode':
plot(x, main = NULL, which = 1, ...)

S3 method for class 'opt.more.par':
plot(x, main = NULL, which = 1, ...)

S3 method for class 'opt.more.par.mode':
plot(x, main = NULL, which = 1, ...)

S3 method for class 'check.these.par':
plot(x, main = NULL, which = 1, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
A result from a corespodning function</td></tr>
<tr valign="top"><td><code>M</code></td>
<td>
A matrix or similar object representing a network</td></tr>
<tr valign="top"><td><code>clu</code></td>
<td>
A partition</td></tr>
<tr valign="top"><td><code>ylab</code></td>
<td>
Label for y axis</td></tr>
<tr valign="top"><td><code>xlab</code></td>
<td>
Label for x axis</td></tr>
<tr valign="top"><td><code>main</code></td>
<td>
Main title</td></tr>
<tr valign="top"><td><code>print.val</code></td>
<td>
Should the values be printed in the matrix</td></tr>
<tr valign="top"><td><code>print.0</code></td>
<td>
If <code>print.val=TRUE</code> Should the 0s be printed in the matrix</td></tr>
<tr valign="top"><td><code>plot.legend</code></td>
<td>
Should the legend for shades be ploted</td></tr>
<tr valign="top"><td><code>print.legend.val</code></td>
<td>
Should the values be printed in the legend</td></tr>
<tr valign="top"><td><code>print.digits.legend</code></td>
<td>
The number of digits that should appear in the legend</td></tr>
<tr valign="top"><td><code>print.digits.cells</code></td>
<td>
The number of digits that should appear in the cells (of the matrix and/or legend)</td></tr>
<tr valign="top"><td><code>print.cells.mf</code></td>
<td>
if not <code>NULL</code>, the above argument is igonred, the cell values are printed as the cell are multiplied by this factor and rounded</td></tr>
<tr valign="top"><td><code>outer.title</code></td>
<td>
Should the title be printed on the 'inner' or 'outer' plot, default is 'inner' if legend is ploted and 'outer' otherwise. May be soon omited.</td></tr>
<tr valign="top"><td><code>title.line</code></td>
<td>
The line (from the top) where the title should be printed. The suitable values depend heavily on the displey type.</td></tr>
<tr valign="top"><td><code>mar</code></td>
<td>
A numerical vector of the form 'c(bottom, left, top, right)' which gives the lines of margin to be specified on the four sides of the plot. The R default for ordianry plots is 'c(5, 4, 4, 2) + 0.1', while this functions default is c(0.5, 7, 8.5, 0) + 0.1.</td></tr>
<tr valign="top"><td><code>cex.val</code></td>
<td>
Size of the values printed. The "default" is 10/"number of units"</td></tr>
<tr valign="top"><td><code>val.y.coor.cor</code></td>
<td>
Correction for centering the values in the sqares in y direction</td></tr>
<tr valign="top"><td><code>val.x.coor.cor</code></td>
<td>
Correction for centering the values in the sqares in x direction</td></tr>
<tr valign="top"><td><code>cex.legend</code></td>
<td>
Size of the text in the legend</td></tr>
<tr valign="top"><td><code>legend.title</code></td>
<td>
The title of the legend</td></tr>
<tr valign="top"><td><code>cex.axes</code></td>
<td>
Size of the characters in axes, 'default' makes the cex so small that all categories can be printed</td></tr>
<tr valign="top"><td><code>print.axes.val</code></td>
<td>
Should the axes values be printed, 'default' prints each axis if 'rownames' or 'colnames' is not 'NULL'</td></tr>
<tr valign="top"><td><code>print.x.axis.val</code></td>
<td>
Should the x axis values be printed, 'default' prints each axis if 'rownames' or 'colnames' is not 'NULL'</td></tr>
<tr valign="top"><td><code>print.y.axis.val</code></td>
<td>
Should the y axis values be printed, 'default' prints each axis if 'rownames' or 'colnames' is not 'NULL'</td></tr>
<tr valign="top"><td><code>x.axis.val.pos</code></td>
<td>
x coordiante of the y axis values</td></tr>
<tr valign="top"><td><code>y.axis.val.pos</code></td>
<td>
y coordiante of the x axis values</td></tr>
<tr valign="top"><td><code>cex.main</code></td>
<td>
Size of the text in the main title</td></tr>
<tr valign="top"><td><code>cex.lab</code></td>
<td>
Size of the text in matrix</td></tr>
<tr valign="top"><td><code>yaxis.line</code></td>
<td>
The position of the y axis (the argument 'line')</td></tr>
<tr valign="top"><td><code>xaxis.line</code></td>
<td>
The position of the x axis (the argument 'line')</td></tr>
<tr valign="top"><td><code>legend.left</code></td>
<td>
How much left should the legend be from the matrix</td></tr>
<tr valign="top"><td><code>legend.up</code></td>
<td>
How much up should the legend be from the matrix</td></tr>
<tr valign="top"><td><code>legend.size</code></td>
<td>
Relative legend size</td></tr>
<tr valign="top"><td><code>legend.text.hor.pos</code></td>
<td>
Horizontal position of the legend text (bottom) - 0 = bottom, 0.5 = middle,...</td></tr>
<tr valign="top"><td><code>par.line.width</code></td>
<td>
The width of the line that seperates the partitions</td></tr>
<tr valign="top"><td><code>par.line.col</code></td>
<td>
The color of the line that seperates the partitions</td></tr>
<tr valign="top"><td><code>IM.dens</code></td>
<td>
The densitiey of shading lines for each block</td></tr>
<tr valign="top"><td><code>IM</code></td>
<td>
The image (as obtaind with <code>crit.fun</code>) of the blockmodel. <code>dens.leg</code> is used to translate this image into <code>IM.dens</code>.</td></tr>
<tr valign="top"><td><code>dens.leg</code></td>
<td>
It is used to translate the <code>IM</code> into <code>IM.dens</code>.</td></tr>
<tr valign="top"><td><code>blackdens</code></td>
<td>
At which density should the values on dark colurs of lines be printed in white.</td></tr>
<tr valign="top"><td><code>plotLines</code></td>
<td>
Should the lines in the matrix be printed - default TRUE, best set to FALSE for larger networks.</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Aditional arguments to <code>plot.default</code> for <code>plot.mat</code> and also to <code>plot.mat</code> for other functions</td></tr>
</table>

<h3>Value</h3>

<p>
The functions are used for their side affect - plotting.</p>

<h3>Author(s)</h3>

<p>
Aleš Žiberna
</p>


<h3>References</h3>

<p>
ŽIBERNA, Aleš (2006): Generalized Blockmodeling of Valued Networks. Social Networks, Jan. 2007, vol. 29, no. 1, 105-126. <a href="http://dx.doi.org/10.1016/j.socnet.2006.04.002">http://dx.doi.org/10.1016/j.socnet.2006.04.002</a>.
</p>
<p>
ŽIBERNA, Aleš. Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. J. math. sociol., 2008, vol. 32, no. 1,  57-84. <a href="http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207">http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207</a>.
</p>


<h3>See Also</h3>

<p>
<code><a href="crit.fun.html">crit.fun</a></code>,<code><a href="opt.par.html">opt.par</a></code>,<code><a href="opt.random.par.html">opt.random.par</a></code>,<code><a href="opt.random.par.html">opt.these.par</a></code>,<code><a href="check.these.par.html">check.these.par</a></code>
</p>


<h3>Examples</h3>

<pre>
#Generation of the network
n&lt;-20
net&lt;-matrix(NA,ncol=n,nrow=n)
clu&lt;-rep(1:2,times=c(5,15))
tclu&lt;-table(clu)
net[clu==1,clu==1]&lt;-rnorm(n=tclu[1]*tclu[1],mean=0,sd=1)
net[clu==1,clu==2]&lt;-rnorm(n=tclu[1]*tclu[2],mean=4,sd=1)
net[clu==2,clu==1]&lt;-rnorm(n=tclu[2]*tclu[1],mean=0,sd=1)
net[clu==2,clu==2]&lt;-rnorm(n=tclu[2]*tclu[2],mean=0,sd=1)

#Ploting the network
plot.mat(M=net, clu=clu)
class(net)&lt;-"mat"
plot(net, clu=clu)
#See corespodning functions for examples for other plotting functions presented, that are esentially only the wrappers for "plot.max"
</pre>



<hr><div align="center">[Package <em>blockmodeling</em> version 0.1.5 <a href="00Index.html">Index]</a></div>

</body></html>
