<html><head><title>Computation of function values by blocks</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>fun.by.blocks(blockmodeling)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   fun.by.blocks">
<param name="keyword" value="R:   fun.by.blocks.default">
<param name="keyword" value="R:   fun.by.blocks.opt.more.par">
<param name="keyword" value=" Computation of function values by blocks">
</object>


<h2>Computation of function values by blocks</h2>


<h3>Description</h3>

<p>
Computes a value of a functions over blocks of a matrix, defined by a partition.
</p>


<h3>Usage</h3>

<pre>
fun.by.blocks(x, ...)

## default S3 method:
fun.by.blocks(M, clu, ignore.daig = identical(ss(diag(M)) &amp;&amp; !is.list(clu), 0), FUN = "mean")

## S3 method for class 'opt.more.par':
fun.by.blocks(x, which = 1, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>M</code></td>
<td>
A matrix representing the (usually valued) network. For now, only one-relational networks are supported. The network can have one or more modes (diferent kinds of units with no ties among themselvs. If the network is not two-mode, the matrix must be square.</td></tr>
<tr valign="top"><td><code>clu</code></td>
<td>
A partition. Each unique value represents one cluster. If the nework is  one-mode, than this should be a vector, else a list of vectors, one for each mode</td></tr>
<tr valign="top"><td><code>ignore.daig</code></td>
<td>
Should the diagonal be ingored. </td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
Function to be computed over the blocks</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
An object of an appropriate class</td></tr>
<tr valign="top"><td><code>which</code></td>
<td>
Which (if several) of the "best" solutions should be used</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Further arguments to <code>fun.by.blocks.default</code> </td></tr>
</table>

<h3>Value</h3>

<p>
A numerical matrix of <code>FUN</code> values by blocks, induced by a partition <code>clu</code></p>

<h3>Author(s)</h3>

<p>
Aleš Žiberna
</p>


<h3>References</h3>

<p>
ŽIBERNA, Aleš (2006): Generalized Blockmodeling of Valued Networks. Social Networks, Jan. 2007, vol. 29, no. 1, 105-126. <a href="http://dx.doi.org/10.1016/j.socnet.2006.04.002">http://dx.doi.org/10.1016/j.socnet.2006.04.002</a>.
</p>
<p>
ŽIBERNA, Aleš. Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. J. math. sociol., 2008, vol. 32, no. 1,  57-84. <a href="http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207">http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207</a>.
</p>


<h3>See Also</h3>

<p>
<code><a href="opt.random.par.html">opt.random.par</a></code>,<code><a href="opt.random.par.html">opt.these.par</a></code>
</p>


<h3>Examples</h3>

<pre>
n&lt;-8 #if larger, the number of partitions increases dramaticaly, as does if we increase the number of clusters
net&lt;-matrix(NA,ncol=n,nrow=n)
clu&lt;-rep(1:2,times=c(3,5))
tclu&lt;-table(clu)
net[clu==1,clu==1]&lt;-rnorm(n=tclu[1]*tclu[1],mean=0,sd=1)
net[clu==1,clu==2]&lt;-rnorm(n=tclu[1]*tclu[2],mean=4,sd=1)
net[clu==2,clu==1]&lt;-rnorm(n=tclu[2]*tclu[1],mean=0,sd=1)
net[clu==2,clu==2]&lt;-rnorm(n=tclu[2]*tclu[2],mean=0,sd=1)

#we select a random parition and then optimise it

all.par&lt;-nkpartitions(n=n, k=length(tclu)) #forming the partitions
all.par&lt;-lapply(apply(all.par,1,list),function(x)x[[1]]) # to make a list out of the matrix

#optimizing 10 random chosen partitions which are suplied to opt.these.par
res&lt;-opt.these.par(M=net,partitions=all.par[sample(1:length(all.par),size=10)],approach="ss",blocks="com")
plot(res) #Hopefully we get the original partition
fun.by.blocks(res) #computing mean by blocks, ignoring the diagonal (default)
res$best[[1]]$BM #the same result computed by opt.these.par when approach="ss" and blocks="com"
</pre>



<hr><div align="center">[Package <em>blockmodeling</em> version 0.1.5 <a href="00Index.html">Index]</a></div>

</body></html>
