<html><head><title>An R package for Generalized and classical blockmodeling of valued networks</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>blockmodeling-package(blockmodeling)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   blockmodeling-package">
<param name="keyword" value=" An R package for Generalized and classical blockmodeling of valued networks">
</object>


<h2>An R package for Generalized and classical blockmodeling of valued networks</h2>


<h3>Description</h3>

<p>
This package is primarily meant as an implementation of Generalized blockmodeling. In addition, functions for computation of (dis)similarities in terms of structural and regular equivalence, plotting and other "utility" functions are provided.
</p>


<h3>Author(s)</h3>

<p>
Aleš Žiberna
</p>


<h3>References</h3>

<p>
ŽIBERNA, Aleš (2006): Generalized Blockmodeling of Valued Networks. Social Networks, Jan. 2007, vol. 29, no. 1, 105-126. <a href="http://dx.doi.org/10.1016/j.socnet.2006.04.002">http://dx.doi.org/10.1016/j.socnet.2006.04.002</a>.
</p>
<p>
ŽIBERNA, Aleš. Direct and indirect approaches to blockmodeling of valued networks in terms of regular equivalence. J. math. sociol., 2008, vol. 32, no. 1,  57-84. <a href="http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207">http://www.informaworld.com/smpp/content?content=10.1080/00222500701790207</a>.
</p>
<p>
DOREIAN, Patrick, BATAGELJ, Vladimir, FERLIGOJ, Anuška (2005): Generalized blockmodeling, (Structural analysis in the social sciences, 25). Cambridge [etc.]: Cambridge University Press, 2005. XV, 384 p., ISBN 0-521-84085-6.
</p>
<p>
White, D. R., K. P. Reitz (1983): "Graph and semigroup homomorphisms on networks of relations". Social Networks, 5, p. 193-234.
</p>
<p>
White, Douglas R.(2005): REGGE (web page). http://eclectic.ss.uci.edu/~drwhite/REGGE/ (12.5.2005).
</p>


<h3>See Also</h3>

<p>
Packages:
<code><a onclick="findlink('sna', 'sna.html')" style="text-decoration: underline; color: blue; cursor: hand">sna</a></code>
<code><a onclick="findlink('network', 'network-package.html')" style="text-decoration: underline; color: blue; cursor: hand">network</a></code>
</p>
<p>
Functions inside this package:
<code><a href="crit.fun.html">crit.fun</a></code>, <code><a href="opt.par.html">opt.par</a></code>, <code><a href="opt.random.par.html">opt.random.par</a></code>, <code><a href="opt.random.par.html">opt.these.par</a></code>, <code><a href="check.these.par.html">check.these.par</a></code>, <code><a href="REGE.html">REGE</a></code>, <code><a href="plot.mat.html">plot.mat</a></code>
</p>


<h3>Examples</h3>

<pre>
n&lt;-8 #if larger, the number of partitions increases dramaticaly, as does if we increase the number of clusters
net&lt;-matrix(NA,ncol=n,nrow=n)
clu&lt;-rep(1:2,times=c(3,5))
tclu&lt;-table(clu)
net[clu==1,clu==1]&lt;-rnorm(n=tclu[1]*tclu[1],mean=0,sd=1)
net[clu==1,clu==2]&lt;-rnorm(n=tclu[1]*tclu[2],mean=4,sd=1)
net[clu==2,clu==1]&lt;-rnorm(n=tclu[2]*tclu[1],mean=0,sd=1)
net[clu==2,clu==2]&lt;-rnorm(n=tclu[2]*tclu[2],mean=0,sd=1)

#we select a random parition and then optimise it

all.par&lt;-nkpartitions(n=n, k=length(tclu)) #forming the partitions
all.par&lt;-lapply(apply(all.par,1,list),function(x)x[[1]]) # to make a list out of the matrix

#optimizing one partition
res&lt;-opt.par(M=net,clu=all.par[sample(1:length(all.par),size=1)],approach="ss",blocks="com")
plot(res) #Hopefully we get the original partition

#optimizing 10 random chosen partitions which are suplied to opt.these.par
res&lt;-opt.these.par(M=net,partitions=all.par[sample(1:length(all.par),size=10)],approach="ss",blocks="com")
plot(res) #Hopefully we get the original partition

#optimizing 10 random chosen partitions with opt.random.par
res&lt;-opt.random.par(M=net,k=2,npar=10,approach="ss",blocks="com")
plot(res) #Hopefully we get the original partition

#Checking all possible partitions
nkpar(n=n, k=length(tclu)) #computing the number of partitions
all.par&lt;-nkpartitions(n=n, k=length(tclu)) #forming the partitions
all.par&lt;-lapply(apply(all.par,1,list),function(x)x[[1]]) # to make a list out of the matrix
res&lt;-check.these.par(M=net,partitions=all.par,approach="ss",blocks="com")
plot(res) #we get the original partition

#using indidect approach - structural equivalence
D&lt;-sedist(M=net)
plot.mat(net, clu=cutree(hclust(d=D,method="ward"),k=2))
</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>blockmodeling</em> version 0.1.5 <a href="00Index.html">Index]</a></div>

</body></html>
